<!DOCTYPE html>
<html>
<head>
  <script src="https://code.jquery.com/jquery-3.3.1.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script language="javascript" type="text/javascript" src="scroll.js"></script>
  <script language="javascript" type="text/javascript" src="prettyprint.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="prettyprint.css">
</head>
<body>
  <!-- <div class="startScreen">
    <h1>Challenges</h1>
    <div class="form-group">
  <!-- <label for="exampleFormControlSelect1"></label>
  <select class="form-control" id="exampleFormControlSelect1">
    <option>None yet!</option>
  </select>
</div>
    <hr>
    <h1>Scrolling Code</h1>
    <div class="fl">
      <div class="form-group">
    <!-- <label for="exampleFormControlSelect1"></label>
    <select class="form-control" id="exampleFormControlSelect1">
      <option>None yet!</option>
    </select>
  </div>
    </div>
    <div class="fr">
      <div class="form-group">
    <!-- <label for="exampleFormControlSelect1"></label> 
    <select class="form-control" id="exampleFormControlSelect1">
      <option>None yet!</option>
    </select>
  </div>
    </div>
  </div>
<br>
  <div class="form-check-inline">
  <input class="form-check-input" type="radio" name="exampleRadios" id="exampleRadios1" value="option1" checked>
  <label class="form-check-label" for="exampleRadios1">
    Default radio
  </label>
</div>
<div class="form-check-inline">
  <input class="form-check-input" type="radio" name="exampleRadios" id="exampleRadios2" value="option2">
  <label class="form-check-label" for="exampleRadios2">
    Second default radio
  </label>
</div>
<div class="form-check-inline">
  <input class="form-check-input" type="radio" name="exampleRadios" id="exampleRadios3" value="option3" disabled>
  <label class="form-check-label" for="exampleRadios3">
    Disabled radio
  </label>
</div> -->
  <div class="wrapper">
<pre class="prettyprint linenums lang-js CodeBoxBuffer">
  // NeuralNetwork visualizer

  const LEVELS = 3;

  class nnv {
    constructor(brain){
      this.inputSize = brain.input_nodes;
      this.hiddenSize = brain.hidden_nodes;
      this.outputSize = brain.output_nodes;
      this.IH_weights = brain.weights_ih.data
      this.HO_weights = brain.weights_ho.data
      this.hidden_Bias = brain.bias_h.data
      this.output_Bias = brain.bias_o.data
      this.hidden_values = brain.HiddenValues.data
      this.output_values = brain.OuputValues.data
      this.input_values = brain.InputValues;
      this.NodeSizeBias = 24;
      this.SizeMax = 50;
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.x = 0;
      this.y = 0;
      this.xSize = 0;
      this.ySize = 0;
      this.YIntervalI = 0;
      this.YIntervalH = 0;
      this.YIntervalO = 0;
      this.XInterval = 0;
      this.YOffset = 0;
      this.XOffset = 0;
    }

    setValues(x, y, xSize, ySize, XOffset, YOffset){
      this.x = x;
      this.y = y;
      this.xSize = xSize;
      this.ySize = ySize;
      this.XOffset = XOffset;
      this.YOffset = YOffset;
      this.XInterval = this.CalcuateXInterval(this.xSize, LEVELS);
      this.YIntervalI = this.CalcuateYInterval(this.ySize, this.inputSize);
      this.YIntervalH = this.CalcuateYInterval(this.ySize, this.hiddenSize);
      this.YIntervalO = this.CalcuateYInterval(this.ySize, this.outputSize);
    }

    draw(){
      if(this.input_values){
        noStroke();
        fill(200);
        rectMode(CENTER);
        rect(this.x,this.y,this.xSize,this.ySize);
        this.drawNodes();
        this.drawLinks();
      }
    }

    drawNodes(){
      let size = this.NodeSizeBias;
      for(let i = 0; i < this.inputSize; i++){
        this.color = this.getColor(this.input_values[i],false);
        fill(this.color);
        let xValue = this.x - this.xSize/2 + 0 * this.XInterval + this.XInterval/2 + this.XOffset;
        let yValue = this.YOffset + i * this.YIntervalI + this.YIntervalI/2;
        ellipse(xValue, yValue, size, size);
      }
      for(let i = 0; i < this.hiddenSize; i++){
        this.color = this.getColor(this.hidden_values[i],false);
        fill(this.color);
        size = this.getSize(this.hidden_Bias[i][0]);
        let xValue = this.x - this.xSize/2 + 1 * this.XInterval + this.XInterval/2 + this.XOffset;
        let yValue = this.YOffset + i * this.YIntervalH + this.YIntervalH/2;
        ellipse(xValue, yValue, size, size);
      }
      for(let i = 0; i < this.outputSize; i++){
        this.color = this.getColor(this.output_values[i],true);
        fill(this.color);
        size = this.getSize(this.output_Bias[i][0]);
        let xValue = this.x - this.xSize/2 + 2 * this.XInterval + this.XInterval/2 + this.XOffset;
        let yValue = this.YOffset + i * this.YIntervalO + this.YIntervalO/2;
        ellipse(xValue, yValue, size, size);
      }
    }

    drawLinks(){
      for(let i = 0; i < this.hiddenSize; i++){
        for(let j = 0; j < this.inputSize; j++){
          let x = this.input_values[i];
          let weight = this.IH_weights[i][j];
          let pSum = x * weight;
          if(abs(pSum) >= 1/this.inputSize){
            this.drawConnection(i,j,1,2,this.IH_weights);
          }
        }
      }

      for(let i = 0; i < this.outputSize; i++){
        for(let j = 0; j < this.hiddenSize; j++){
          let x = this.hidden_values[i];
          let weight = this.HO_weights[i][j];
          let pSum = x * weight;
          if(abs(pSum) >= 1/(this.hiddenSize+1)){
            this.drawConnection(i,j,2,3,this.HO_weights);
          }
        }
      }
    }

    drawConnection(i,j,layerX,layerY,weights){
      let x1 = 0;
      let y1 = 0;
      let x2 = 0;
      let y2 = 0;

      if(layerX == 1){
        x1 = this.x - this.xSize/2 + 0 * this.XInterval + this.XInterval/2 + this.XOffset;
        y1 = this.YOffset + j * this.YIntervalI + this.YIntervalI/2;
      }
      if(layerX == 2){
        x1 = this.x - this.xSize/2 + 1 * this.XInterval + this.XInterval/2 + this.XOffset;
        y1 = this.YOffset + j * this.YIntervalH + this.YIntervalH/2;
      }
      if(layerX == 3){
        x1 = this.x - this.xSize/2 + 2 * this.XInterval + this.XInterval/2 + this.XOffset;
        y1 = this.YOffset + j * this.YIntervalO + this.YIntervalO/2;
      }
      if(layerY == 1){
        x2 = this.x - this.xSize/2 + 0 * this.XInterval + this.XInterval/2 + this.XOffset;
        y2 = this.YOffset + i * this.YIntervalI + this.YIntervalI/2;
      }
      if(layerY == 2){
        x2 = this.x - this.xSize/2 + 1 * this.XInterval + this.XInterval/2 + this.XOffset;
        y2 = this.YOffset + i * this.YIntervalH + this.YIntervalH/2;
      }
      if(layerY == 3){
        x2 = this.x - this.xSize/2 + 2 * this.XInterval + this.XInterval/2 + this.XOffset;
        y2 = this.YOffset + i * this.YIntervalO + this.YIntervalO/2;
      }

      stroke(0);
      strokeWeight(abs(weights[i][j]) * 2);
      line(x1,y1,x2,y2);
    }

    getColor(val, output){
      let r = 0;
      let g = 0;
      let b = 0;
      if(output){
        let max = this.getHighestOutput();
        if(val == max){
          r = 0;
          g = 255;
          b = 0;
        } else {
          r = 255;
          g = 0;
          b = 0;
        }
      } else {
        if(val <= .5){
          r = 255;
          g = val * 2 * 255;
          b = 0;
        } else {
          r = (val - .5) * 2 * 255;
          g = 255;
          b = 0;
        }
      }
      let color = [3]
      color[0] = r;
      color[1] = g;
      color[2] = b;
      return color;
    }

    CalcuateYInterval(Height, Size){
      let UsableSpace = Height - 2 * this.YOffset;
      let Interval = UsableSpace / Size;
      return floor(Interval);
    }

    CalcuateXInterval(Width, Size){
      let UsableSpace = Width - 2 * this.XOffset;
      let Interval = UsableSpace / Size;
      return floor(Interval);
    }

    getSize(value){
      value = value * this.SizeMax;
      if(value <= 10) value = this.NodeSizeBias;
      return value;
    }

    getHighestOutput(){
      let max = 0;
      for(let j = 0; j < this.outputSize; j++){
        if(this.output_values[j] >= this.output_values[max]) max = j;
      }
      return this.output_values[max];
    }
  }
  // let m = new Matrix(3,2);


class Matrix {
  constructor(rows, cols) {
    this.rows = rows;
    this.cols = cols;
    this.data = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
  }

  copy() {
    let m = new Matrix(this.rows, this.cols);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        m.data[i][j] = this.data[i][j];
      }
    }
    return m;
  }

  static fromArray(arr) {
    return new Matrix(arr.length, 1).map((e, i) => arr[i]);
  }

  static subtract(a, b) {
    if (a.rows !== b.rows || a.cols !== b.cols) {
      console.log('Columns and Rows of A must match Columns and Rows of B.');
      return;
    }

    // Return a new Matrix a-b
    return new Matrix(a.rows, a.cols)
      .map((_, i, j) => a.data[i][j] - b.data[i][j]);
  }

  toArray() {
    let arr = [];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        arr.push(this.data[i][j]);
      }
    }
    return arr;
  }

  randomize() {
    return this.map(e => Math.random() * 2 - 1);
  }

  add(n) {
    if (n instanceof Matrix) {
      if (this.rows !== n.rows || this.cols !== n.cols) {
        console.log('Columns and Rows of A must match Columns and Rows of B.');
        return;
      }
      return this.map((e, i, j) => e + n.data[i][j]);
    } else {
      return this.map(e => e + n);
    }
  }

  static transpose(matrix) {
    return new Matrix(matrix.cols, matrix.rows)
      .map((_, i, j) => matrix.data[j][i]);
  }

  static multiply(a, b) {
    // Matrix product
    if (a.cols !== b.rows) {
      console.log('Columns of A must match rows of B.')
      return;
    }

    return new Matrix(a.rows, b.cols)
      .map((e, i, j) => {
        // Dot product of values in col
        let sum = 0;
        for (let k = 0; k < a.cols; k++) {
          sum += a.data[i][k] * b.data[k][j];
        }
        return sum;
      });
  }

  multiply(n) {
    if (n instanceof Matrix) {
      if (this.rows !== n.rows || this.cols !== n.cols) {
        console.log('Columns and Rows of A must match Columns and Rows of B.');
        return;
      }

      // hadamard product
      return this.map((e, i, j) => e * n.data[i][j]);
    } else {
      // Scalar product
      return this.map(e => e * n);
    }
  }

  map(func) {
    // Apply a function to every element of matrix
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        let val = this.data[i][j];
        this.data[i][j] = func(val, i, j);
      }
    }
    return this;
  }

  static map(matrix, func) {
    // Apply a function to every element of matrix
    return new Matrix(matrix.rows, matrix.cols)
      .map((e, i, j) => func(matrix.data[i][j], i, j));
  }

  print() {
    console.table(this.data);
    return this;
  }

  serialize() {
    return JSON.stringify(this);
  }

  static deserialize(data) {
    if (typeof data == 'string') {
      data = JSON.parse(data);
    }
    let matrix = new Matrix(data.rows, data.cols);
    matrix.data = data.data;
    return matrix;
  }
}

if (typeof module !== 'undefined') {
  module.exports = Matrix;
}
</pre>

  </div>

  </body>
  </html>
